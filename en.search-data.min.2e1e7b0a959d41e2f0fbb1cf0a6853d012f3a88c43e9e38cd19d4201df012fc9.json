[{"id":0,"href":"/docs/server/nestjs/nestjs%EB%A1%9C-springboot-cache-%ED%9D%89%EB%82%B4%EB%82%B4%EA%B8%B0/","title":"NestJS로 SpringBoot Cache 흉내내기","section":"NestJS","content":" Pain Point # 최근 사내 서비스에 대규모 고객사가 이전하게 되면서, 애플리케이션 전반의 부하 안정성 개선이 최우선 과제로 떠올랐습니다.\n현재 사내 서비스는 모두 MSA 기반으로 구성되어 있었고, 저는 여러 서비스들을 팔로업하는 \u0026lsquo;BFF(Backend for Frontend)\u0026rsquo; 서버를 담당하고 있습니다. BFF는 구조적 특성상 다양한 API를 인증하고, 응답 데이터를 팔로업 과정에서 병목 현상이 발생하기 쉬운 구간입니다.\n하지만 기존 캐시 로직에는 두 가지 큰 문제가 있었습니다.\n높은 결합도: 캐시 로직이 비즈니스 로직과 복잡하게 얽혀있었습니다. 코드를 읽기도 어려웠을 뿐더러, 새로운 캐시를 추가하거나 기존 로직을 수정할 때마다 사이드 이펙트를 걱정해야 하는 \u0026lsquo;기술 부채\u0026rsquo; 상태였습니다. 비효율적인 저장소: 모든 캐시를 Redis에만 의존하다 보니, 거의 변하지 않는 정적인 데이터(예: 카테고리 목록)마저도 매번 네트워크 I/O를 발생시키며 Redis를 조회하는 비효율이 존재했습니다. Example # 안녕하세요.\n{{% button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] %}}Get Home{{% /button %}} {{% button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; %}}Contribute{{% /button %}} Get Home\nContribute\n"}]