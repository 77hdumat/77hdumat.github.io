[{"id":0,"href":"/docs/server/nestjs/nestjs-cache-%EC%96%B4%EB%94%94%EA%B9%8C%EC%A7%80-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B3%A0-%EA%B3%84%EC%8B%A0%EA%B0%80%EC%9A%94/","title":"NestJS 캐시 어디까지 활용하고 계신가요?","section":"NestJS","content":" 개요 # 최근 큰 규모의 고객사가 저희 서비스로 이전하게 되면서 서비스 전반의 부하 안정성 개선이 최우선 과제로 떠올랐습니다. 서비스 아키텍처는 MSA로 구성되어 있었고, 저는 이 서비스들을 팔로업 해 FE 협업을 지원하는 \u0026lsquo;BFF(Backend for Frontend)\u0026rsquo; 서버를 담당하고 있습니다.\nBFF 서버는 다양한 엔드포인트에 의존하다 보니 트래픽이 집중될 때 병목이 가장 발생하기 쉬운 구간이었습니다. 따라서 기존 비즈니스 로직과 복잡하게 얽혀있던 캐시 구현을 모두 걷어낸 후, 지속 가능하고 편한 캐시 관리 방안을 모색했습니다.\n기존 캐시 로직에는 몇 가지 문제점이 있었습니다.\n비즈니스 로직 오염 조건부 캐싱의 어려움 캐시 무효화의 일관성 문제 계층형 캐시 미지원 캐시 쇄도 문제 40kb 이상의 큰 문자열을 I/O 할 때 생기는 응답 지연 문제 여러 문제가 있었지만 선언적 방식으로 캐시 로직을 관리할 수 있도록 리팩토링을 먼저 진행하기로 했습니다.\n선언적 캐시 데코레이터 지원 # 당시 기능을 빠르게 붙여야 했던 탓에 구현에만 급급했었고 다음과 같은 코드가 남발하고 있었습니다.\nasync getPaymentsKey(@Ctx() user: UserContext) { const storeId = user.storeId; const cacheKey = `get-clientKey-${storeId}`; let cacheValue = null; try { cacheValue = await this.cacheService.get(cacheKey); } catch (err) { this.logger.error(`캐시 조회 실패: ${cacheKey}`, err.stack); cacheValue = null; } if (cacheValue) { return cacheValue; } const {clientKey, state} = await this.paymentsServcie.getPaymentsKey(storeId); try { if (state === \u0026#39;ACTIVE\u0026#39;) { await this.cacheService.set(cacheKey, {clientKey, state}); } } catch (err) { this.logger.error(`캐시 설정 실패: ${cacheKey}`, err.stack); } return new GetPaymentsKeyResponse(clientKey, state); } 당시 NestJS 캐시 모듈은 메서드 호출을 가로채 실행 전 후로 원하는 로직을 실행 시킬 수 있는 횡단 관심사 기능(AOP)을 제대로 제공하고 있았습니다. (interceptor 가 있었지만 라우터 핸들러에서만 동작했기에 적합하지 않다고 판단했습니다.) 그렇다면 NestJS에서는 선언적 캐시를 위한 데코레이터를 어떻게 구현할 수 있을까요?\n간단한 해결책으로 @toss/nestjs-aop 를 사용했습니다. 1\nnestjs-aop는 라우터 핸들러에서만 동작하는 Interceptor가 아닌 부팅 라이프 사이클을 이용해 DI 컨테이너가 초기화된 후, AOP의 대상이 되는 메서드를 찾아 런타임에 직접 교체(Monkey-Patching) 하는 원리로 서비스 내부 메서드를 포함한 모든 프로바이더에 AOP를 적용할 수 있게 합니다.\n내부 동작 원리는 크게 [마킹] → [탐색] → [교체] → [실행] 4단계로 나뉩니다.\n마킹 # metadata 식별자와 metadata를 인자로 받아 고유한 AOP 심볼로 데코레이터를 생성합니다. applyDecorators 를 통해 두 개의 데코레이터 함수를 순차적으로 적용합니다. 코드를 살펴보면 다음과 같습니다.\nexport const createDecorator = ( metadataKey: symbol | string, metadata?: unknown, ): MethodDecorator =\u0026gt; { const aopSymbol = Symbol(\u0026#39;AOP_DECORATOR\u0026#39;); return applyDecorators( // 1. 메타 데이터 저장 (Reflect를 통해 메서드에 부착되고 추후 Discovery 과정에서 식별됩니다.) (target: object, propertyKey: string | symbol, descriptor: PropertyDescriptor) =\u0026gt; { return AddMetadata\u0026lt;symbol | string, AopMetadata\u0026gt;(metadataKey, { originalFn: descriptor.value, // 원본 메서드 metadata, // 데코레이터에 전달된 옵션 인자 aopSymbol, // 고유 심볼 })(target, propertyKey, descriptor); }, // 2. 원본 메서드에 프록시 메서드 Wrapping (_: object, propertyKey: string | symbol, descriptor: PropertyDescriptor) =\u0026gt; { const originalFn = descriptor.value; descriptor.value = function (this: any, ...args: unknown[]) { // 데코레이터가 붙은 메서드가 호출되면, 런타임은 원본 함수 대신 wrappedFn 함수를 실행하게 됩니다. const wrappedFn = this[aopSymbol]?.[propertyKey]; if (wrappedFn) { return wrappedFn.apply(this, args); } // AopModule이 없거나 실패한 경우 원본 메서드 실행 (Fallback) return originalFn.apply(this, args); }; Object.defineProperty(descriptor.value, \u0026#39;name\u0026#39;, { value: propertyKey.toString(), writable: false, }); Object.setPrototypeOf(descriptor.value, originalFn); }, ); }; descriptor는 자바스크립트 런타임이 메서드 데코레이터가 실행될 때 자동으로 전달하는 표준 내장 객체입니다. 해당 인자는 자바스크립트의 Object.getOwnPropertyDescriptor()와 동일합니다.\nDMN 공식 문서에 따르면 주어진 객체는 속성 설명자인 descriptor 를 반환하고, 반환 값은 다음과 같다고 합니다. 2\nvalue: 원본 메서드 writable: 값을 덮어쓸 수 있는지 여부 enumerable: 열거 가능 여부 configurable: 속성을 삭제하거나 descriptor를 수정할 수 있는지 여부 descriptor 통해 원본 메서드를 식별하여 AOP를 적용할 수 있게 됩니다.\n탐색 # 탐색은 AutoAspectExecutor 클래스의 OnModuleInit 부팅 라이프사이클 훅에서 시작됩니다. 애플리케이션이 시작되면 모든 의존성 주입이 완료되고 이후 discoveryService 를 통해 모든 프로바이더를 조회할 수 있게 됩니다. 조회된 프로바이더는 lookupLazyDecorators 를 통해 @Aspect() 에 포함된 메타데이터와 wrap 함수가 존재하는 클래스를 찾아낼 수 있습니다.\nexport class AutoAspectExecutor implements OnModuleInit { private readonly wrappedMethodCache = new WeakMap(); constructor( private readonly discoveryService: DiscoveryService, private readonly metadataScanner: MetadataScanner, private readonly reflector: Reflector, ) { } onModuleInit() { this.bootstrapLazyDecorators(); } private bootstrapLazyDecorators() { // 모든 프로바이더를 조회합니다. const controllers = this.discoveryService.getControllers(); const providers = this.discoveryService.getProviders(); // 조회된 프로바이더는 lookupLazyDecorators로 넘겨집니다. const lazyDecorators = this.lookupLazyDecorators(providers); if (lazyDecorators.length === 0) { return; } const instanceWrappers = providers .concat(controllers) .filter(({instance}) =\u0026gt; instance \u0026amp;\u0026amp; Object.getPrototypeOf(instance)); // lazyDecorator 즉, AOP 클래스를 모두 찾아(Outer Loop) 모든 프로바이더를 순회(Inner Loop)합니다. for (const lazyDecorator of lazyDecorators) { for (const wrapper of instanceWrappers) { this.applyLazyDecorator(lazyDecorator, wrapper); } } } // AOP 데코레이터와 `wrap` 함수가 존재하는 클래스를 찾아 반환합니다. // 이 구간에서 나중에 구현하게 될 cacheable.aspect.ts가 찾아집니다. private lookupLazyDecorators(providers: InstanceWrapper[]): LazyDecorator[] { const {reflector} = this; return providers .filter((wrapper) =\u0026gt; wrapper.isDependencyTreeStatic()) .filter(({instance, metatype}) =\u0026gt; { if (!instance || !metatype) { return false; } const aspect = reflector.get\u0026lt;string\u0026gt;(ASPECT, metatype) || reflector.get\u0026lt;string\u0026gt;(ASPECT, Object.getPrototypeOf(instance).constructor); if (!aspect) { return false; } return typeof instance.wrap === \u0026#39;function\u0026#39;; }) .map(({instance}) =\u0026gt; instance); } private applyLazyDecorator(lazyDecorator: LazyDecorator, instanceWrapper: InstanceWrapper\u0026lt;any\u0026gt;) { const target = instanceWrapper.isDependencyTreeStatic() ? instanceWrapper.instance : instanceWrapper.metatype?.prototype; if (!target) { console.debug(\u0026#39;[applyLazyDecorator] not found target\u0026#39;); return; } // 클래스의 모든 메서드를 metadataScanner로 조회합니다 const propertyKeys = this.metadataScanner.scanFromPrototype( target, instanceWrapper.isDependencyTreeStatic() ? Object.getPrototypeOf(target) : target, (name) =\u0026gt; name, ); // createDecorator를 통해 메타데이터를 생성할때 인자로 넘겨 받은 metadataKey를 조회합니다. const metadataKey = this.reflector.get(ASPECT, lazyDecorator.constructor); for (const propertyKey of propertyKeys) { // @see: https://github.com/rbuckton/reflect-metadata/blob/9562d6395cc3901eaafaf8a6ed8bc327111853d5/Reflect.ts#L938 const targetProperty = target[propertyKey]; if (!targetProperty || (typeof targetProperty !== \u0026#34;object\u0026#34; \u0026amp;\u0026amp; typeof targetProperty !== \u0026#34;function\u0026#34;)) { continue; } // 프로바이더 내 메서드를 순회하면서 metadataKey가 적용되어있는 메서드를 찾아 AOP 메타데이터를 반환합니다. const metadataList: AopMetadata[] = this.reflector.get\u0026lt;AopMetadata[]\u0026gt;( metadataKey, targetProperty, ); if (!metadataList) { continue; } // 찾은 메서드는 실제 AOP 로직을 연결하기위해 wrapMethod 넘겨집니다. for (const aopMetadata of metadataList) { this.wrapMethod({lazyDecorator, aopMetadata, methodName: propertyKey, target}); } } } } 교체 # wrapMethod 는 AOP 로직(lazyDecorator.wrap)을 실행하여 AOP가 적용된 함수(wrappedMethod)를 생성합니다. 이 함수는 WeakMap 을 통해 캐시되어 성능을 최적화합니다. 이렇게 생성된 wrappedFn 은 [마킹] 단계에서 만든 프록시 함수가 참조하는 aopSymbol 에 연결됩니다.\nprivate wrapMethod({ lazyDecorator, aopMetadata, methodName, target, }: { lazyDecorator: LazyDecorator; aopMetadata: AopMetadata; methodName: string; target: any; }) { // 원본 메서드, 데코레이터에 전달된 인자, 고유 심볼 조회 const { originalFn, metadata, aopSymbol } = aopMetadata; const self = this; const wrappedFn = function (this: object, ...args: unknown[]) { const cache = self.wrappedMethodCache.get(this) || new WeakMap(); const cached = cache.get(originalFn); if (cached) { return cached.apply(this, args); } // 클래스 인스턴스와 원본 메서드와 인자, 메서드 이름을 전달하고 캐시합니다. const wrappedMethod = lazyDecorator.wrap({ instance: this, methodName, method: originalFn.bind(this), metadata, }); cache.set(originalFn, wrappedMethod); self.wrappedMethodCache.set(this, cache); return wrappedMethod.apply(this, args); }; target[aopSymbol] ??= {}; // 데코레이터의 프록시 함수를 wrappedFn으로 교체합니다. target[aopSymbol][methodName] = wrappedFn; } 실행 # 애플리케이션 로직 어딘가에서 someService.someMethod() 를 실행하고, 해당 메서드에 AOP 데코레이터가 붙어있다면 [마킹] 단계에서 덮어쓴 프록시 함수가 먼저 실행됩니다. 프록시 함수는 this[aopSymbol][methodName] 을 호출하며, [교체] 단계에서 wrappedFn 을 연결해 두었기 때문에 AOP 클래스가 실행됩니다.\n아래 예제는 추후 구현하게 될 캐시 AOP 클래스의 실행 순서를 간략하게 표현한 코드입니다.\n@Aspect() @Injectable() export class CacheableAspect implements LazyDecorator\u0026lt;any, CacheableOption\u0026gt; { wrap({method, metadata: options}) { return (...args: any[]) =\u0026gt; { console.log(\u0026#39;AOP: Before original method\u0026#39;); // (\u0026#39;before\u0026#39; 로직) // \u0026#39;원본 함수\u0026#39;가 \u0026#39;스텁 함수\u0026#39; 내부에 매핑 (Closure) const result = method(...args); console.log(\u0026#39;AOP: After original method\u0026#39;); // (\u0026#39;after\u0026#39; 로직) return result; }; } } 간단(?)하게 내부 동작 원리를 살펴보았으니 이제 구현만 하면 되겠습니다.\n구현하기 # @toss/nestjs-aop\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMDN - Object.getOwnPropertyDescriptor()\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"}]