[{"id":0,"href":"/docs/server/nestjs/nestjs%EB%A1%9C-springboot-cache-%ED%9D%89%EB%82%B4%EB%82%B4%EA%B8%B0/","title":"NestJS로 Spring Boot Cache 흉내내기","section":"NestJS","content":" Pain Point # 최근 사내 서비스에 큰 규모의 고객사가 이전하게 되면서, 부하 안정성 개선이 최우선 과제로 떠올랐습니다.\n사내 모든 서비스는 MSA로 구성되어 있었고, 저는 여러 서비스들을 팔로업하는 \u0026lsquo;BFF(Backend for Frontend)\u0026rsquo; 서버를 담당하고 있었기에 다양한 엔드포인트를 팔로업하는 과정에서 생기는 병목을 개선해야만 했습니다. 우선 가장 적은 리소스로 큰 효과를 낼 수 있는 캐시를 다양한 메서드에 적용하기로 했습니다.\n기존 캐시 로직에는 몇 가지 문제점이 있었습니다.\n비즈니스 로직의 오염 조건부 캐싱의 어려움 취약한 에러 핸들링 캐시 무효화(Eviction) 로직의 분산으로 인한 일관성 문제 계층형 캐시 미지원 (NestJS는 기본 기능으로 계층형 캐싱을 지원하지 않습니다.) 위와 같은 문제점을 해결하지 않고 비즈니스 로직을 구현하게 되면 다음과 같은 코드가 탄생합니다. 😢\nasync getPaymentsKey(@Ctx() user: UserContext) { const storeId = user.storeId; const cacheKey = `get-clientKey-${storeId}`; let cacheValue = null; try { cacheValue = await this.cacheService.get(cacheKey); } catch (err) { this.logger.error(`캐시 조회 실패: ${cacheKey}`, err.stack); cacheValue = null; } if (cacheValue) { return cacheValue; } const {clientKey, state} = await this.paymentsServcie.getPaymentsKey(storeId); try { if (state === \u0026#39;ACTIVE\u0026#39;) { await this.cacheService.set(cacheKey, {clientKey, state}); } } catch (err) { this.logger.error(`캐시 설정 실패: ${cacheKey}`, err.stack); } return new GetPaymentsKeyResponse(clientKey, state); } 깔끔한 문제 해결을 위해 Spring Boot의 @Cacheable 어노테이션과 같은 선언적 캐싱 방식을 NestJS 프로젝트에 도입하기로 했습니다.\nSpring Boot Cache 참고하기 # 문제 해결에 앞서 참고할만한 스프링 부트 캐시의 옵션을 몇가지 추려보겠습니다.\n@Cacheable # Option Description cacheNames / value 캐시를 그룹화하는 네임스페이스 key 캐시 항목을 식별하는 고유 키 cacheManager 여러 캐시 전략(Redis, Memory) 중 하나 선택 condition 메서드 실행 전 캐시 로직을 실행할지 결정하는 SpEL unless 메서드 실행 후 결과값을 캐시에 저장할지 결정하는 SpEL @CacheEvict # Option Description cacheNames / value 삭제할 캐시가 속한 네임스페이스 key 삭제할 특정 캐시 항목의 키 cacheManager 캐시 삭제를 수행할 캐시 매니저를 선택 condition 메서드 실행 전 캐시 삭제 로직을 실행할지 결정하는 함수 allEntries true일 경우, key와 무관하게 네임스페이스의 모든 항목을 삭제 beforeInvocation true일 경우, 메서드 실행 전에 캐시 삭제 (메서드 성공 여부와 무관) 캐시 네임스페이스 / 메서드 실행 전, 후 평가 / 캐시 전략 선택 등 다양한 옵션들을 추려보았습니다. BFF 서비스에서 사용하기에 부족하지 않은 옵션들 입니다. 하지만 구현하기에 앞서 한가지 큰 문제에 직면합니다.\nNestJS에서 선언적 캐싱 사용하기 # NestJS는 Spring Boot의 AOP(Aspect-Oriented Programming) 즉, 메서드 호출을 가로채 메서드 실행 전 후로 원하는 로직을 실행 시킬 수 있는 기능을 제공하고 있지 않다는 점입니다. 그렇다면 NestJS에서 선언적 캐시를 위한 데코레이터를 어떻게 구현할 수 있을까요? (비슷한 기능으로 interceptor가 있지만 라우트 핸들러에서만 동작하기 때문에 적합하지 않습니다.)\n간단한 해결책으로 @toss/nestjs-aop 를 사용합니다. 1\ntoss/nestjs-aop의 핵심 원리는 NestJS의 표준 Interceptor 방식이 아닌, 부팅 라이프 사이클을 활용해 DI 컨테이너가 초기화된 후, AOP의 대상이 되는 메서드를 찾아 런타임에 직접 교체(Monkey-Patching) 하는 것입니다. 이는 서비스 간의 내부 메서드 호출을 포함한 모든 Provider의 메서드에 AOP를 적용할 수 있게 합니다.\n내부 동작 원리는 크게 [마킹] → [탐색] → [교체] → [실행] 4단계로 나뉩니다.\n마킹 create-decorator.ts 에서 Symbol과 metadata를 인자로 받아 메서드 데코레이터를 생성합니다. 이 데코레이터는 Reflect.defineMetadata를 통해 메타데이터를 메서드에 부착되어 추후 식별에 사용됩니다. @toss/nestjs-aop\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"}]