[{"id":0,"href":"/docs/server/nestjs/nestjs%EB%A1%9C-springboot-cache-%ED%9D%89%EB%82%B4%EB%82%B4%EA%B8%B0/","title":"NestJS로 Spring Boot Cache 흉내내기","section":"NestJS","content":" Pain Point # 최근 사내 서비스에 큰 규모의 고객사가 이전하게 되면서, 부하 안정성 개선이 최우선 과제로 떠올랐습니다.\n현재 사내의 모든 서비스는 MSA로 구성되어 있었고, 저는 관련 서비스들을 팔로업하는 \u0026lsquo;BFF(Backend for Frontend)\u0026rsquo; 서버를 담당하고 있습니다. BFF는 구조적 특성상 다양한 API를 인증하고, 응답 데이터를 팔로업 과정에서 병목이 발생하기 쉬운 구간이었고, 가장 적은 리소스로 큰 효과를 낼 수 있는 캐시 로직을 우선적으로 개선하고자 했습니다.\n기존 캐시 로직에는 두 가지 문제점이 있었습니다.\n캐시 로직이 비즈니스 로직과 복잡하게 얽혀있었습니다. 모든 캐시를 Redis에만 의존하고 있었습니다. 거의 변하지 않는 static한 데이터(폰트 등)는 네트워크 I/O없이 인메모리를 활용하고 싶었습니다. 이러한 문제들을 해결하기 위해 Spring Boot의 @Cacheable 어노테이션처럼, 캐싱 로직을 직접 작성하지 않고 사용할 수 있는 선언적 캐싱 방식을 NestJS의 데코레이터로 구현하기로 했습니다.\nSpring Boot Cache 살펴보기 # 구현하기에 앞서 스프링 부트 캐시의 옵션을 살펴보겠습니다.\n@Cacheable Description cacheNames / value 캐시를 그룹화하는 네임스페이스 key 캐시 항목을 식별하는 고유 키 cacheManager 여러 캐시 전략(Redis, Memory) 중 하나를 선택 condition 메서드 실행 전 캐시 로직을 실행할지 결정하는 SpEL unless 메서드 실행 후 결과값을 캐시에 저장할지 결정하는 SpEL @CacheEvict Description cacheNames / value 삭제할 캐시가 속한 네임스페이스 key 삭제할 특정 캐시 항목의 키 cacheManager 캐시 삭제를 수행할 캐시 매니저를 선택 condition 메서드 실행 전 캐시 삭제 로직을 실행할지 결정하는 함수 allEntries true일 경우, key와 무관하게 name 네임스페이스의 모든 항목을 삭제 beforeInvocation true일 경우, 메서드 실행 전에 캐시를 삭제(메서드 실패와 무관) "}]